{
  "name": "tmatch",
  "version": "1.0.2",
  "description": "This module exists to facilitate the `t.match()` method in [`tap`](http://npm.im/tap).",
  "main": "index.js",
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/tmatch.git"
  },
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/isaacs/tmatch/issues"
  },
  "homepage": "https://github.com/isaacs/tmatch#readme",
  "devDependencies": {
    "tap": "^1.4.1"
  },
  "readme": "# tmatch\n\nThis module exists to facilitate the `t.match()` method in\n[`tap`](http://npm.im/tap).\n\nIt checks whether a value matches a given \"pattern\".  A pattern is an\nobject with a set of fields that must be in the test object, or a\nregular expression that a test string must match, or any combination\nthereof.\n\nThe algorithm is borrowed heavily from\n[`only-shallow`](http://npm.im/only-shallow), with some notable\ndifferences with respect to the handling of missing properties and the\nway that regular expressions are compared to strings.\n\n## usage\n\n```javascript\nvar matches = require('tmatch')\n\nif (!matches(testObject, pattern)) console.log(\"yay! diversity!\");\n\n// somewhat more realistic example..\nhttp.get(someUrl).on('response', function (res) {\n  var expect = {\n    statusCode: 200,\n    headers: {\n      server: /express/\n    }\n  }\n\n  if (!tmatch(res, expect)) {\n    throw new Error('Expect 200 status code from express server')\n  }\n})\n```\n\n## details\n\nCopied from the source, here are the details of `only-shallow`'s algorithm:\n\n1. If the object is a string, and the pattern is a RegExp, then return\n   true if `pattern.test(object)`.\n2. Use loose equality (`==`) only for all other value types\n   (non-objects).  `tmatch` cares more about shape and contents than\n   type. This step will also catch functions, with the useful\n   (default) property that only references to the same function are\n   considered equal.  'Ware the halting problem!\n3. `null` *is* an object – a singleton value object, in fact – so if\n   either is `null`, return object == pattern.\n4. Since the only way to make it this far is for `object` or `pattern`\n   to be an object, if `object` or `pattern` is *not* an object,\n   they're clearly not a match.\n5. It's much faster to compare dates by numeric value (`.getTime()`)\n   than by lexical value.\n6. Compare RegExps by their components, not the objects themselves.\n7. The parts of an arguments list most people care about are the\n   arguments themselves, not the callee, which you shouldn't be\n   looking at anyway.\n8. Objects are more complex:\n   1. Return `true` if `object` and `pattern` both have no properties.\n   2. Ensure that cyclical references don't blow up the stack.\n   3. Ensure that all the key names in `pattern` exist in `object`.\n   4. Ensure that all of the associated values match, recursively.\n\n## license\n\nISC. Go nuts.\n",
  "readmeFilename": "README.md",
  "_id": "tmatch@1.0.2",
  "_from": "tmatch@^1.0.2"
}
